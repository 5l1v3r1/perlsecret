=encoding utf8

=head1 НАИМЕНОВАНИЕ

perlsecret - Cекретные операторы и константы Perl

=head1 КРАТКИЙ ОБЗОР

Cекретный операторы Perl:

    Оператор     Кличка                       Функция
    ======================================================
    0+           Венус Venus                  Приведение к цифре
    @{[ ]}       Детскаякаляска Babycart      интерполяция списка
    !!           2 удара Bang bang            логическое преобразование
    }{           Эскимосское приветствие      КОНЕЦ блока для однострочного скрипта
    ~~           Дюймовыйчервь Inchworm       скалярный
    ~-           Дюймовыйчервь на палке       декремент высокого приоритета
    -~           Дюймовыйчервь на палке       декремент высокого приоритета
    -+-          Космическая станция          Приведение к цифре высокого приоритета
    =( )=        Гоатсе                       скалярный / списочный контекст
    =< >=~       Пылающий X-Wing Истребитель  ищем во входных данных и присваиваем захваченное
    ~~<>         Кайт, девочка убийца         Одиночная строка ввода
    <<m=~m>> m ; Богатый двухлезвийный меч    Многострочный комментарий
    -=!   -=!!   Простак                      условное уменьшение
    +=!   +=!!   Филипс                       условное увеличение
    x=!   x=!!   Крестовая                    условный резет на ''
    *=!   *=!!   Торкс Шестилучевая отвертка  условный резет на 0
    ,=>          Подмигивающая жирная запятая не стрингифицирующая жирная запятая
    ()x!!        Смелость Enterprise          Сквош логического списка
    0+!!         Ключ к истине                числовое преобразование логических значений
    ||()         Эбботт и Костелло Камеди дуэт удалить ложный скаляр из списка
    //()         Наклон Эбботта и Костелло    удалить undef из списка

Perl секретные константы:

    Константы   Кличка (Nickname)           Значение
    ======================================================
    <=><=><=>   Космический флот            0
    <~>         Амфисбена Двойной путь      $ENV{HOME}

=head1 ОПИСАНИЕ

Perl имеет давнюю традицию давать прозвища для некоторых из своих операторов
(возможноя форма очеловечивания). Эти прозвища основаны на
скорее на виде оператора, чем на его функции.
Известные примеры I<бриллиантовый оператор> (C<< <> >>),
по прозвищу Стена Женевы и  I<оператор космического корабля> (C<< <=> >>), 
прозванный Рендаль Шварц.
Вот некоторые менее известные операторы Perl с ником I<толстая запятая>
(C<< => >>) и I<болтовня> (C<< ... >>).

"I<Cекретный операторы>" Perl были обнаружены (или созданы)
Perl обфускаторами и Perl гольфистами, обычно при поиске более короткого пути
выполнения операции.
Секретный операторы не являются на самом деле секретными, и они не являются на самом деле
операторами. Perl анализатор специально не признает их,
и не пытается скрывать их от вас.
Но они, являются операторами в том смысле, Perl программистам достаточно посмотреть
 на их конструкцию, чтобы понять, что они делают, не задумываясь о более мелких элементах
 и в конечном итоге добавляют их в свою коллецию инструментов.
Они являются секретами в том смысле, что они должны обнаружены
их будущем пользоватем (программистом), потому что они
явно не описаны в основной документации Perl.

Так как секретные операторы не являются операторами, они не имеют реальных имен, и
поэтому они нуждаются в прозвища (никнеймах).
Как видно из описания Perl операторов выше их имя обычно связано с их формой.

Термин "секретный оператор", вероятно, был придуман Абигейлом в
 сообщении на C<comp.lang.perl.misc> в январе 2003 года.

=head2 Слово предупреждения

Многие из этих "операторов", не подходят для производственного кода,
потому что они являются неясными для непосвященных, хотя некоторые из них - это просто имена
для общих идиом (словосочетаний, фр. idiome «язык, наречие» происх от др.-греч. ἰδίωμα «особенность, своеобразие).
Реально секретные операторы используются гольфистами,
обфускаторами и людьми, которые любят
 повеселиться с их любимым языком программирования.

Вы можете попробовать их дома, но они могут быть не безопасны для работы!

=head1 СЕКРЕТНЫЕ ОПЕРАТОРЫ

В следующем разделе представлены секретные операторы Perl с
некоторым историческим контекстом, объяснением того, как они работают и
примерами использования.

=head2 Венера(Venus)

    0+
    +0

Оператор I<Венера> - это очень распространенный фразеологизм. Он выполняет
превращение в цифру, нумификацию значения стоящего справа/слева
в зависимости от используемых версий. (Это достигается путем
использование идентификатора добавления I<+>).

    print 0+ '23a';                 # 23

    print 0+ '3.00';                # 3

    print 0+ '1.2e3';               # 1200

    print 0+ '42 EUR';              # 42

    print 0+ 'two cents';           # 0

    $ref = [];
    print 0+ $ref, ' ', "$ref";     # 164094424 ARRAY(0x9c7e1d8)

    print 0+ $!, ' ', $!;           # 2 No such file or directory


Обратите внимание, что C<0+> — это имя метода, для "числового преобразования"
 в модуле C<overload>.

=head2 Детская коляска (Baby cart)

    @{[ ]}

Открыта Лари Воллом, 1994.
(Альтернативные клички:  "шоппинг троллей", "коляска", "черепаха")

Оператор I<Детская коляска> выполняет интерполяцию списка внутри строки.
Элементы списка разделяются значением C<$">.

    # SQL в heredoc (документ-здесь)
    local $" = ',';
    my $sth = $self->execute( << "SQL" );
     SELECT id, name, salary
       FROM employee
      WHERE id IN (@{[ keys %employee ]})
    SQL

    # аргументы находятся в хэше %arg
    # и выводятся неизвестные аргументы
    die "Uuh?: @{[ sort keys %arg ]}\n"

Еще один вариант использования – для взлома алиасов (т.е. создании копии); Например,
чтобы избежать фатальной ошибки при C<попытке модификации значения только для чтения>
при выполнении следующего кода:

    for (qw( 1 2 3 )) {
        $_ = $_ * $_;    # надуманный
        print "площадь: $_\n";
    }

С детской коляской (babycart) изменяемые данные фактически копируются в скаляр.

    for ( @{[ qw( 1 2 3 ) ]} ) {
        $_ = $_ * $_;    # надуманный
        print "площадь: $_\n";
    }

Это I<контейнер>, или I<окаймляющий>  (I<циркумфикс>) operator. Выражение внутри 
C<[]> выполняется в списочном контексте и сохраняется в анонимном массиве,
который сразу разыменовывается  с помощью C<@{}>.

Вы это иногда увидите это в рабочем коде.

=head2 2 удара Bang bang

    !!

Этот оператор был в общем использовании программистами C даже до существования Perl.
Он выполняет логическое преобразование, выполняя логическое отрицание
дважды.

    my $true  = !! 'a string';   # теперь 1
    my $false = !! undef;        # теперь ''

=head2 Приветствие Эскимосов (Eskimo greeting)

    }{

(Альтернативный ник: "бабочка")

Открыт Абигалем в 1997.

Оператор I<приветствие Эскимосов> является блоком C<END> для однострочников.

Следующая программа подсчитывает и выводит число строк во входных данных:

    $ perl -lne '}{print$.'

Приветствие Эскимосов злоупотребляет использование опций B<-p> и B<-n> генерируя
Perl код (показано, используя модуль C<B::Deparse>):

    $ perl -MO=Deparse -lne '}{print$.'
    -e syntax OK
    BEGIN { $/ = "\n"; $\ = "\n"; }
    LINE: while (defined($_ = <ARGV>)) {
        chomp $_;
    }
    {
        print $.;
    }

Открытие было сделано после того, как Perl Journal опубликовал интервью с
Чипом Сальзенбергом(Chip Salzenberg), в котором он объяснил, что хак perl использует для реализации
C<< -p >> и C<< -n >>.

Этнографическое примечание: в современной Западной культуре эскимосский поцелуй - это
, когда люди целуются друг с другом соприкасая носы. Это основывается
на традиционном инуитском приветствии, названном I<куник>, ранние исследователи
Арктики назвали его "эскимосский поцелуй" ("Eskimo kissing"), когда они впервые увидели его.
Сам куник не является поцелелуем, он не эротичен, это просто форма нежного приветствия.

=head2 Дюймовый_червь (Inchworm)

    ~~

Этот оператор в основном короче C<scalar>(убирает целых 4 символа!)
используя ту же идею, как секретный оператор bang bang.

    $ perl -Esay~~localtime
    Tue Mar 13 19:53:25 2012

Дюймочервь выглядит очень похоже на смарт матч оператор, представленный
в Perl 5.10, но так как это на самом деле последовательность двух унарных операторов,
анализатор Perl не сможет смешать его с двоичным смарт матчем.

Обратите внимание, что Perl C<~> является чувствительным операндом: если его операнд имеет числовое
значение (либо потому, что был присвоен номер, в результате числовая
операция, или используется в числовом контексте), это побитовое числовое
отрицание (сначала неявно преобразует целое число без знака (unsigned integer (UV)), или 
за областью  C<use L<integer>>, знаковое целое число, (signed integer (IV))); в противном случае это
строковое поразрядное(побитовое) отрицание.

И это объясняет, как эта операция отличается от C<!!>. Вместо того, чтобы заставить операнд
 быть булевым (логическим), он применяет его или к строке или к цифре(в зависимости от операндов).

Таким образом, для большинства входных данных, Дюймочервь (inchworm) действует так же, как C<scalar()>.

Примеры исключений:

    # с плавающей точкой
    $x = 1.23;
    print ~~$x;                # 1

    # строка используется в числовом контексте
    $x = "1.23";
    print ~~$x if $x != 0;     # 1

    # целое число вне диапазона (out of range)
    use Config '%Config';

    $x = 2**( 8 * $Config{uvsize} );
    print ~~$x;                # UV_MAX

    $x = -1;
    print ~~$x;                # UV_MAX

    $x = 2**( 8 * $Config{uvsize} - 1 );
    {
        use integer;
        print ~~$x;            # IV_MIN
    }

    $x = -2**( 8 * $Config{uvsize} - 1 ) - 1;
    {
        use integer;
        print ~~$x;            # IV_MIN
    }

Но это также удобно, как собирательное для получения строки из объектов,
перегрузите его некоторым полезным образом:

    use DateTime;
    use JSON;
    my $now = DateTime->now;
    print encode_json { time => ~~$now };

=head2 Дюймочервь на палке (Inchworm on a stick)

    ~-
    -~

Открыт Томом Хоспелом, 2002.

Эти два оператора выполняют высокоприоритетный декремент (C<~->) и
 высокоприоритетный инкремент(C<-~>) для целых чисел (на архитектуре
дополнительного кода ( two-complement) 
https://ru.wikipedia.org/wiki/Дополнительный_код_(представление_числа)).
Этот трюк программисты языка ассемблера использую на протяжении десятилетий.

В C, Python и Ruby они работают на всех целых числах. Из-за того, как оператор C<~>
реализован в Perl (мало известный факт, что побитовые
операторы Perl приводят операнд к  беззнаковому целому ( unsigned integers) 
  без C<use L<integer>> и к знаковому целому (signed integers) 
  с C<use integer>), эта пара
секретных операторов ограничивается целыми числами со знаком.
Это на самом деле еще большее ограничение, по умолчанию: C<~-> только уменьшает целые числа
больше 0 и C<-~> только увеличивающем целые числа меньше 0. Для того, чтобы
Дюймочервь на палке (Inchworm on a stick)
 работал на всех целых числах, он должен быть использован
в сфере  C<use integer>, таким образом знаковые целые(signed integers)
 используются повсеместно в битовых операциях.

Этот гольф методика позволяет избавиться от пары скобок:

    $y = ~-$x * 4;    # аналогично $y = ($x-1)*4;

Вот доказательство:

    $x - 1 == - ( -$x ) - 1

В двудополнительной архитектуре, чтобы получить обратное числа,
все, что вам нужно сделать это сделать инверсию (flip) всех битов и добавить 1. То есть,

    -$i == ~$i + 1

Используем это, чтобы заменить C< - ( -$x ) > на показанное выше, мы получаем:

    $x - 1 == ( ~-$x + 1 ) - 1

И после устранения единиц из уравнения,

    $x - 1 == ~-$x

ЧТО И ТРЕБОВАЛОСЬ ДОКАЗАТЬ. (QED - от лат. quod erat demonstrandum)

Для C<-~>, доказательство аналогично:

    $x + 1 == - ( -$x ) + 1

    $x + 1 == - ( ~$x + 1 ) + 1

    $x + 1 == -~$x - 1 + 1

    $x + 1 == -~$x

В обеих версиях высокий приоритет исходит из того, что  C<~>
и унарный C<-> оба имеют более высокий приоритет, чем все другие арифметические
операторы (за исключением C<**>).

Мнемосхема: назад стоящий дюймочервь на палке(C<~->) уменьшает,
а дюймочервь по ходу движения на палке (C<-~>) приращяет.

=head2 Космическая станция (Space station)

    -+-

Открыт Алистером Макглинчи, 2005.

Этот оператор выполняет приведение к цифре с высоким приоритетом.

    print -+- '23a';                # 23

    print -+- '3.00';               # 3

    print -+- '1.2e3';              # 1200

    print -+- '42 EUR';             # 42

    $ref = [];
    print -+- $ref, ' ', "$ref";    # 151097816 ARRAY(0x90191d8)

    print -+- $!, ' ', $!;          # 2 Нет такого файла или каталога

Во-первых это выглядит точно как оператор Венеры. Однако, потому что
оператор Венеры  использует двоичный C<+>, он имеет более низкий приоритет, чем
операторы умножения, такие как как C<*> или C<x>.С другой стороны
оператор космической станции является объединением трех унарных операторов,
и поэтому имеет более высокий приоритет.

В следующем примере мы будем пытаться печатать приведнную к цифре строку
 C<'20GBP'> (т.eе C<'20'>) повторенную 3 раза.

    # неправильно: выведет нумификацию '20GBP20GBP20GBP'
    print 0+ '20GBP' x 3;           # 20

    # неправильно: это эквивалентно ( print '20' ) x 3
    print( 0+ '20GBP' ) x 3;        # 20

    # правильно: но слишком длинно, слишком полисповски
    print( ( 0 + '20GBP' ) x 3 );   # 202020

    # верно: использование оператора космическая станция (space station)
    print -+- '20GBP' x 3;          # 202020

Тем не менее, т.к. унарный минус просто заменяеть начальный C <-> или C <+> строки 
их аналогом, космическая станция B<не> переводит в цифры I<строки, начинающиеся с минуса> 
или I <строки, которые не начинаются с числа>:

    print -+- 'two cents';          # +two cents

    print -+- '-2B' x 5;            # -2B-2B-2B-2B-2B

В примере выше, C<-+- '-2B'> производит строку C<'-2B'>,
в то время как C<0+ '-2B'> дал бы ожидаемое число (C<-2>).

=head2 Гоатсе, Коза (Goatse)

    =( )=

(Еще одно имя: "Сатурн")

Если вы не понимаете имя этого оператора, считайте себя счастливчиком.
Вам рекомендуется B<не> искать его в Интернете для визуального объяснения.

Оператор гоатсе предоставляет списочный контекст его правую сторону и
возвращает количество элементов на ее левой стороне.
Обратите внимание, что левая сторона должна обеспечивать скалярный контекст; очевидно списочный
контекст с левой стороны будут получать пустой список в середине.

Объяснение того, что присвоение списка в скалярном контексте возвращает
количество элементов в правой части назначения, независимо от
как много из этих элементов были на самом деле присваивоены переменным. В этом
случае все элементы справа просто передают пустой список
(и поэтому отбрасываются).

    # считает число слов в $_
    $n =()= /word1|word2|word3/g;

    # $n = 1
    $n =()= "abababab" =~ /a/;

    # $n = 4
    $n =()= "abababab" =~ /a/g;

Оператор goatse представляет собой контейнер (sic), поэтому он также может использоваться для
присвойте значения с правой стороны переменных внутри него.
The goatse operator is a container (sic), so it can also be used to
assign values from the right-hand side to the variables inside it.

    # $n = 4; $b = 'a'
    $n =($b)= "abababab" =~ /a/g;

    # $n = 4; @c = qw( a a a a )
    $n =(@c)= "abababab" =~ /a/g;

In some cases, the full goaste is not needed, because there is no need
to store the value in a variable. The side-effect of list assignment in
scalar context can be obtained with a I<right-handed goaste> (C<()=>)
used in a scalar context provided by some other mean than assignement
to a scalar.
For example:

    # remove empty array refs
    @arrays = ( [], [1], [ 1, 2 ], [], [ 5 .. 9 ] );

    # @filled = ( [1], [ 1, 2 ], [ 5 .. 9 ] );
    @filled = grep +()= @$_, @arrays;

(The C<+> is in the above line is a no-op, used to tell C<grep> that the
parentheses are not enclosing its arguments.)

Here's a convoluted example where C<=()=> seems to be the proper
construct to use, but it's actually another secret operator that
really does the trick.

Imagine you want to know in how many elements C<< split() >> would split
a string, but do not care about the elements themselves. Using C<split()>
in scalar context:

    my $count = split /:/, $string;

Gives the correct answer, but also a warning:

    Use of implicit split to @_ is deprecated

Using C<=()=> to force scalar context on the left side (to get the number
of substrings) and list context on the right side (to avoid the deprecated
not-in-list-context construct) seems like the proper solution:

    my $count =()= split /:/, $string;

It does not warn indeed, but always returns C<1> (which is usually wrong).

The reason is that C<split()> never splits to more fields than necessary.
And the compiler interprets storing the results in C<()> as not caring
about the results, so C<split()> will B<not split the string at all>,
and thus return the full string, which gives a list of only one element
in scalar context, hence the C<1>.

You have two options to address this. First, you can override C<split()>'s
optimization by explicitly asking it to split into an unlimited number of
fields:

    my $count =()= split /:/, $string, -1;

Or else you can defeat the optimization by using another secret operator
instead, the I<baby cart>:

    my $count = @{[ split /:/, $string ]};

This causes C<split()> to detect that its caller can store any number of
fields, thus it will actually do the work before the anonymous
array is thrown away after being used in scalar context.


=head2 Flaming X-Wing

     =<>=~

Discovered by Philippe Bruhat, 2007.

This operator applies a regular expression to a single line of input
and assigns the captured values to the expression to its left-hand side.

    # pick named fields from input
    @data{@fields} =<>=~ $regexp;

The above statement decomposes as follows: C<=~> provides scalar context
to C<< <> >> on its left, thus matching on a single line of input.
If the regular expression contains captures, having an array-like
structure on the left side of the C<=> provides list context, and the
captured data is assigned to the structure.

This operator is also a container. So the X-Wing can have a pilot!

    # use the source, Luke!
    $luke = \*DATA;
    @data{@fields} =<$luke>=~ $regexp;

=head2 Kite

     ~~<>

Discovered by Philippe Bruhat, 2012.
(Alternate nickname: "sperm")

This operator is actually a combination of the inchworm and the diamond
operator. It provides scalar context to the C<readline()> builtin, thus
returning a single line of input.

It's only useful in list context (since C<< <> >> already returns a
single line of input in scalar and void contexts), for example for getting
several lines at once:

    @triplets = ( ~~<>, ~~<>, ~~<> );    # three sperms in a single egg?

Like the other operators based on bracketing constructs, the kite is a
container, and can carry a payload (a file handle, in this case).

Note that when the filehandle is exhausted, the kite operator will
return the empty string instead of C<undef>.

Mnemonic: It provides a feature that is tied to one line, a string,
as it were. (Tye McQueen in L<http://www.perlmonks.org/?node_id=959906>).


=head2 Ornate double-bladed sword

    <<m=~m>>
    m
    ;

Created by Abigail, 2003, for comp.lang.perl.misc.

This operator provides multi-line comments, by clever use
of heredoc syntax and beautiful symmetry.
Quoting C<< <slrnb382jc.tfm.abigail@alexandra.abigail.nl> >>:

    <<m=~m>>
      Use the secret operator on the previous line.
      Put your comments here.
      Lots and lots of comments.

      You can even use blank lines.
      Finish with a single
    m
    ;

The "ornament" is the C<m> ribbon with the C<;> throwing blade attached
to it.

Note that the "commented" text is actually a double-quoted string in
void context, which can have some side effects.

=head2 Screwdriver operators

Discovered by Dmitry Karasik, 2007, while looking for C<!>-based operators.

All screwdriver operators are conditional operators. Like screwdrivers,
they come in 4 major types, with different handle lengths.

=over 4

=item *

Flathead

    -=!!
    -=!

This operator provides conditional decrement:

    $x -=!! $y     # $x-- if $y;
    $x -=!  $y     # $x-- unless $y;

=item *

Phillips

    +=!!
    +=!

This operator provides conditional increment:

    $x +=!! $y;    # $x++ if $y;
    $x +=!  $y;    # $x++ unless $y;

=item *

Torx

    *=!!
    *=!

This operator provides conditional reset to C<0>:

    $x *=!! $y;    # $x = 0 unless $y;
    $x *=!  $y;    # $x = 0 if $y;

The torx screwdriver operator does not work properly with negative numbers
different from C<-1> on Perl versions lower than or equal to 5.13.5.
It also fails with C<-1> on Perl versions lower than or equal to 5.7.0.

=item *

Pozidriv

    x=!!
    x=!

This operator provides conditional reset to C<''>:

    $x x=!! $y;    # $x = '' unless $y;
    $x x=!  $y;    # $x = '' if $y;

(This one was discovered by Philippe Bruhat in 2009, while preparing a
talk about the secret operators.)

=back

Mnemonic: the screwdriver's head is the best mnemonic (C<-> and C<+>
for increment and decrement, C<*> for the null number, C<x> for the
null string).


=head2 Winking fat comma

    ,=>

Discovered by Abigail, 2010.
(Alternate nickname: "grappling hook")

Visually looks like a fat comma, but without the left-hand side behaviour.

This operator is used to retain the documenting features of the fat comma,
while disabling the string interpretation of the word to its left.

    use constant APPLE   =>  1;
    use constant CHERRY  =>  2;
    use constant BANANA  =>  3;

    %hash = (
      APPLE   ,=>  "green",
      CHERRY  ,=>  "red",
      BANANA  ,=>  "yellow",
    );

is equivalent to:

    %hash = ( 1, "green", 2, "red", 3, "yellow" );

Mnemonic: the comma C<,> is an off-switch for the fat comma's stringification.

=head2 Enterprise

    ( )x!!

Discovered by Aristotle on PerlMonks, 2006.
(Alternate nicknames: "NCC-1701", "snail")

It is often necessary to conditionally include items in a list:

    my @shopping_list = ('bread', 'milk');
    push @shopping_list, 'apples'   if $cupboard{apples} < 2;
    push @shopping_list, 'bananas'  if $cupboard{bananas} < 2;
    push @shopping_list, 'cherries' if $cupboard{cherries} < 20;
    push @shopping_list, 'tonic'    if $cupboard{gin};

The Enterprise lets you build the list and add only the items that
match the condition, in a single statement:

    my @shopping_list = (
        'bread',
        'milk',
       ('apples'   )x!! ( $cupboard{apples} < 2 ),
       ('bananas'  )x!! ( $cupboard{bananas} < 2 ),
       ('cherries' )x!! ( $cupboard{cherries} < 20 ),
       ('tonic'    )x!! $cupboard{gin},
    );

This operator is a container, which means the Enterprise can have a
large crew.

The Enterprise is simply a list repetition operator C<< ()x >>
followed by a boolean (see the L<Bang bang> operator above) which will be
interpreted as 1 or 0 in a numeric context.
Note that the expression on the left is always evaluated, regardless of
the state of the condition.

Because of precedence issues, complex conditions on the tail of the
Enterprise may need to be put between parentheses.

=head2 Key to the truth

    0+!!

Discovered by Toby Inkster, 2013.

This operator is a combination of the Venus and bang bang operators.
It simply makes the boolean false into the C<0> numeric value.

    my $true  = 0+!! 'a string';    # now 1
    my $false = 0+!! undef;         # now 0

=head2 Abbott and Costello

    ||()

Discovered by Yves Orton.

This operator makes a false value disappear in list context.
It simply replaces a false scalar by the empty list.

    my @shopping_list = (
        'bread',
        'milk',
        $this ||(),
        $that ||(),
        'apples'
    );

Mnemonic: one is tall (and also the "straight man") and one is fat,
just like the famous comedy duo.

=head2 Leaning Abbott and Costello

    //()

Proposed by Damien Krotkine, 2014.

This operator works exactly like the L<Abbott and Costello>, except
that it only makes C<undef> disappear in list context.

This operator only works in Perl versions above 5.10.

Mnemonic: in this version, the "straight man" is leaning
(and so the associativity is really "(leaning Abbott) and Costello").

=head1 SECRET CONSTANTS

=head2 Space fleet

    <=><=><=>

Discovered by Damian Conway.

Even though it looks like a sequence of three spaceship operators,
only the middle ship is an actual spaceship. The two outer "spaceships"
are actually calls to C<glob("=")>.

This constant has the value C<0>.

=head2 Amphisbaena

    <~>

Discovered by Rafaël Garcia-Suarez, 2009.

Under Unix, will be equal to the real user home directory (by using C<glob>).
On Win32 it will expand to C<$ENV{HOME}> if it is set (which is quite uncommon)
or return C<'~'> else.

=head1 AUTHOR

Philippe Bruhat (BooK)

=head1 ACKNOWLEDGMENTS

The author would like to thank José Castro, Andrew Savige, Dmitry
Karasik, Abigail, Yitzchak Scott-Thoennes, Zefram, Tye McQueen, Maxim
Vuets, Aristotle Pagaltzis, Toby Inkster, Ævar Arnfjörð Bjarmason,
Rafaël Garcia-Suarez, Andreas J. König, Andy Armstrong, Pau Amma,
Keith C. Ivey, Michael R. Wolf, Olivier Mengué, Yves Orton, Damien Krotkine,
Diab Jerius, Ivan Bessarabov
and the Fun With Perl mailing list for inspiration, suggestions and patches.

=head1 CONTRIBUTING

If you know of other secret operators or constants, please let me know!

However, before sending me your latest creation, be aware that, although
these are not set in stone, I consider the following criteria before
adding an operator or constant to this list:

=over 4

=item *

does it have a nickname? (usually one that matches its ASCII-art shape)

=item *

is it actually used in the wild?

=item *

does it have a golf-specific interest? (i.e. does it perform some useful
operation in significantly fewer characters than "normal" Perl code?)

=item *

does it have some historical interest?

=back

=head1 REFERENCES

As shown below, most of the secret operator action happens
on the Fun With Perl mailing-list.

=over 4

=item *

Around 1993, according to Randal Schwartz in his "I<My half-life with Perl>"
talk given on July 25, 2013 at OSCON:

I<Larry's daughter (Geneva?) named the E<lt>E<gt> operator for me (I named the E<lt>=E<gt>)>

=item *

Post C<< <1994May1.035104.25990@netlabs.com> >> in C<comp.lang.perl>

Larry Wall discovers the baby cart and describes it as "a way to
interpolate function results into a string".

=item *

Post C<< <slrnb382jc.tfm.abigail@alexandra.abigail.nl> >> in C<comp.lang.perl.misc>

Abigail coins the term "secret operator" to describe C<< <<m=~m>> m ; >>.

=item *

L<http://www.nntp.perl.org/group/perl.fwp/2005/02/msg3691.html>

Original "secret operators" thread.
Several of the detailed explanations in this manual page come from this thread.

=item *

L<http://www.nntp.perl.org/group/perl.fwp/2005/02/msg3708.html>

Description of the space station operator.

=item *

L<http://www.nntp.perl.org/group/perl.fwp/2005/02/msg3712.html>

Philippe Bruhat uses the word "venus" to describe C<0+>.

=item *

L<http://www.nntp.perl.org/group/perl.fwp/2006/07/msg3855.html>

Naming the baby cart operator.

=item *

L<http://www.nntp.perl.org/group/perl.fwp/2006/07/msg3891.html>

Aristotle Pagaltzis explains how the baby cart can be used to break aliasing.

=item *

L<http://www.perlmonks.com/?node_id=564792>

I<Secret Perl Operators: the boolean list squash operator, x!!>,
by Aristotle Pagaltzis, describes the Enterprise operator.

=item *

L<http://www.nntp.perl.org/group/perl.fwp/2007/11/msg4006.html>

Description of the flaming X-Wing secret operator.

=item *

L<http://www.nntp.perl.org/group/perl.fwp/2007/11/msg4028.html>

Description of the screwdriver operators, and other C<!>-based operators.

=item *

L<http://www.nntp.perl.org/group/perl.golf/2009/06/msg2524.html>

Description of the fourth screwdriver operator (Pozidriv).

=item *

L<http://www.nntp.perl.org/group/perl.fwp/2012/03/msg4169.html>

Description of the sperm/kite operator.

=item *

L<http://www.nntp.perl.org/group/perl.fwp/2012/04/msg4192.html>

Proposal for an alternate, family-friendly, nickname for the goatse
operator, with a second order inside joke.

=item *

The Abbott and Costello operator was first presented to me on 2013-09-25
by Yves Orton in private messages.

I tried to propose "Laurel and Hardy" as a more internationally
understable alternative, but it turns out Hardy is I<both> the fat and
the tall one.

=item *

The key to the truth operator was described to me on 2013-09-28
by Toby Inkster on the C<#moose> IRC channel and private messages.

=item *

On 2014-02-18, on the C<#perlfr> IRC channel, Damien Krotkine notes that
he uses C<//()> more than C<||()>, to which Philippe Bruhat answers
immediately with the name "Leaning Abbot and Costello", noting that
Abbot is the tall one.

=back

More secret operators didn't make it to this list, because they
don't have a name yet.

=over 4

=item *

L<http://www.nntp.perl.org/group/perl.fwp/2007/11/msg4028.html>

The fwp post that presents the screwdriver operators also presents a
few more C<!>-based operators.

=back

=head1 COPYRIGHT

Copyright 2010-2014 Philippe Bruhat (BooK).

=head1 LICENSE

This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

